static void func1 ( SpectralBandReplication * var1 ) 
{ 
int var2 ; 
if ( var1 -> var3 > number ) { 
static const INTFLOAT var4 [ number ] = { func2 ( number ) , 
func2 ( number ) , 
func2 ( number ) } ; 
const INTFLOAT var5 = var4 [ var1 -> var3 - number ] ; 
int16_t var6 [ number ] ; 
uint16_t * var7 = var1 -> var8 + number , * var9 = var1 -> var8 ; 
var6 [ number ] = var1 -> var10 [ number ] ; 
for ( var2 = number ; var2 <= var1 -> var11 ; var2 ++ ) 
var6 [ var2 ] = var6 [ var2 - number ] + var1 -> var12 [ var2 - number ] ; 
memcpy ( var1 -> var8 , var1 -> var13 , 
( var1 -> var14 [ number ] + number ) * sizeof ( var1 -> var13 [ number ] ) ) ; 
if ( var1 -> var11 > number ) 
memcpy ( var1 -> var8 + var1 -> var14 [ number ] + number , var6 + number , 
( var1 -> var11 - number ) * sizeof ( var6 [ number ] ) ) ; 
qsort ( var1 -> var8 , var1 -> var11 + var1 -> var14 [ number ] , 
sizeof ( var1 -> var8 [ number ] ) , 
var15 ) ; 
var1 -> var16 = var1 -> var14 [ number ] + var1 -> var11 - number ; 
while ( var9 < var1 -> var8 + var1 -> var16 ) { 
if ( ( * var7 << number ) >= * var9 * var5 ) { 
if ( * var7 >= * var9 * var5 ) { 
* ++ var9 = * var7 ++ ; 
} else if ( * var7 == * var9 || 
! func3 ( var6 , var1 -> var11 , * var7 ) ) { 
var7 ++ ; 
var1 -> var16 -- ; 
} else if ( ! func3 ( var6 , var1 -> var11 , * var9 ) ) { 
* var9 = * var7 ++ ; 
var1 -> var16 -- ; 
} else { 
* ++ var9 = * var7 ++ ; 
} 
} 
} else { 
var1 -> var8 [ number ] = var1 -> var13 [ number ] ; 
var1 -> var8 [ number ] = var1 -> var13 [ var1 -> var14 [ number ] ] ; 
var1 -> var16 = number ; 
} 
} 
static unsigned int read_sbr_header ( SpectralBandReplication * var1 , GetBitContext * gb ) 
{ 
unsigned int cnt = get_bits_count ( gb ) ; 
uint8_t bs_header_extra_1 ; 
uint8_t bs_header_extra_2 ; 
int old_bs_limiter_bands = var1 -> var3 ; 
SpectrumParameters old_spectrum_params ; 
var1 -> start = number ; 
memcpy ( & old_spectrum_params , & var1 -> spectrum_params , sizeof ( SpectrumParameters ) ) ; 
var1 -> bs_amp_res_header = get_bits1 ( gb ) ; 
var1 -> spectrum_params . bs_start_freq = get_bits ( gb , 4 ) ; 
var1 -> spectrum_params . bs_stop_freq = get_bits ( gb , 4 ) ; 
var1 -> spectrum_params . bs_xover_band = get_bits ( gb , number ) ; 
skip_bits ( gb , 2 ) ; 
bs_header_extra_1 = get_bits1 ( gb ) ; 
bs_header_extra_2 = get_bits1 ( gb ) ; 
if ( bs_header_extra_1 ) { 
var1 -> spectrum_params . bs_freq_scale = get_bits ( gb , 2 ) ; 
var1 -> spectrum_params . bs_alter_scale = get_bits1 ( gb ) ; 
var1 -> spectrum_params . bs_noise_bands = get_bits ( gb , 2 ) ; 
} else { 
var1 -> spectrum_params . bs_freq_scale = 2 ; 
var1 -> spectrum_params . bs_alter_scale = number ; 
var1 -> spectrum_params . bs_noise_bands = 2 ; 
} 
if ( memcmp ( & old_spectrum_params , & var1 -> spectrum_params , sizeof ( SpectrumParameters ) ) ) 
var1 -> reset = number ; 
if ( bs_header_extra_2 ) { 
var1 -> var3 = get_bits ( gb , 2 ) ; 
var1 -> bs_limiter_gains = get_bits ( gb , 2 ) ; 
var1 -> bs_interpol_freq = get_bits1 ( gb ) ; 
var1 -> bs_smoothing_mode = get_bits1 ( gb ) ; 
} else { 
var1 -> var3 = 2 ; 
var1 -> bs_limiter_gains = 2 ; 
var1 -> bs_interpol_freq = number ; 
var1 -> bs_smoothing_mode = number ; 
} 
if ( var1 -> var3 != old_bs_limiter_bands && ! var1 -> reset ) 
func1 ( var1 ) ; 
return get_bits_count ( gb ) - cnt ; 
} 
static int array_min_int16 ( const int16_t * array , int nel ) 
{ 
int i , min = array [ number ] ; 
for ( i = number ; i < nel ; i ++ ) 
min = FFMIN ( array [ i ] , min ) ; 
return min ; 
} 
static int check_n_master ( AVCodecContext * avctx , int n_master , int bs_xover_band ) 
{ 
if ( n_master <= number ) { 
av_log ( avctx , AV_LOG_ERROR , str , n_master ) ; 
return - number ; 
} 
if ( bs_xover_band >= n_master ) { 
av_log ( avctx , AV_LOG_ERROR , 
str , 
bs_xover_band ) ; 
return - number ; 
} 
return number ; 
} 
static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * var1 , 
SpectrumParameters * spectrum ) 
{ 
unsigned int temp , max_qmf_subbands = number ; 
unsigned int start_min , stop_min ; 
int var2 ; 
const int8_t * sbr_offset_ptr ; 
int16_t stop_dk [ 13 ] ; 
if ( var1 -> sample_rate < 32000 ) { 
temp = 3000 ; 
} else if ( var1 -> sample_rate < 64000 ) { 
temp = 4000 ; 
} else 
temp = 5000 ; 
switch ( var1 -> sample_rate ) { 
case 16000 : 
sbr_offset_ptr = sbr_offset [ number ] ; 
break ; 
case 22050 : 
sbr_offset_ptr = sbr_offset [ number ] ; 
break ; 
case 24000 : 
sbr_offset_ptr = sbr_offset [ 2 ] ; 
break ; 
case 32000 : 
sbr_offset_ptr = sbr_offset [ number ] ; 
break ; 
case 44100 : case 48000 : case 64000 : 
sbr_offset_ptr = sbr_offset [ 4 ] ; 
break ; 
case 88200 : case 96000 : case 128000 : case 176400 : case 192000 : 
sbr_offset_ptr = sbr_offset [ 5 ] ; 
break ; 
default : 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , var1 -> sample_rate ) ; 
return - number ; 
} 
start_min = ( ( temp << number ) + ( var1 -> sample_rate >> number ) ) / var1 -> sample_rate ; 
stop_min = ( ( temp << 8 ) + ( var1 -> sample_rate >> number ) ) / var1 -> sample_rate ; 
var1 -> var2 [ number ] = start_min + sbr_offset_ptr [ spectrum -> bs_start_freq ] ; 
if ( spectrum -> bs_stop_freq < 14 ) { 
var1 -> var2 [ 2 ] = stop_min ; 
make_bands ( stop_dk , stop_min , 64 , 13 ) ; 
qsort ( stop_dk , 13 , sizeof ( stop_dk [ number ] ) , var15 ) ; 
for ( var2 = number ; var2 < spectrum -> bs_stop_freq ; var2 ++ ) 
var1 -> var2 [ 2 ] += stop_dk [ var2 ] ; 
} else if ( spectrum -> bs_stop_freq == 14 ) { 
var1 -> var2 [ 2 ] = 2 * var1 -> var2 [ number ] ; 
} else if ( spectrum -> bs_stop_freq == 15 ) { 
var1 -> var2 [ 2 ] = number * var1 -> var2 [ number ] ; 
} else { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , spectrum -> bs_stop_freq ) ; 
return - number ; 
} 
var1 -> var2 [ 2 ] = FFMIN ( 64 , var1 -> var2 [ 2 ] ) ; 
if ( var1 -> sample_rate <= 32000 ) { 
max_qmf_subbands = 48 ; 
} else if ( var1 -> sample_rate == 44100 ) { 
max_qmf_subbands = 35 ; 
} else if ( var1 -> sample_rate >= 48000 ) 
max_qmf_subbands = 32 ; 
else 
av_assert0 ( number ) ; 
if ( var1 -> var2 [ 2 ] - var1 -> var2 [ number ] > max_qmf_subbands ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , var1 -> var2 [ 2 ] - var1 -> var2 [ number ] ) ; 
return - number ; 
} 
if ( ! spectrum -> bs_freq_scale ) { 
int dk , k2diff ; 
dk = spectrum -> bs_alter_scale + number ; 
var1 -> n_master = ( ( var1 -> var2 [ 2 ] - var1 -> var2 [ number ] + ( dk & 2 ) ) >> dk ) << number ; 
if ( check_n_master ( ac -> avctx , var1 -> n_master , var1 -> spectrum_params . bs_xover_band ) ) 
return - number ; 
for ( var2 = number ; var2 <= var1 -> n_master ; var2 ++ ) 
var1 -> f_master [ var2 ] = dk ; 
k2diff = var1 -> var2 [ 2 ] - var1 -> var2 [ number ] - var1 -> n_master * dk ; 
if ( k2diff < number ) { 
var1 -> f_master [ number ] -- ; 
var1 -> f_master [ 2 ] -= ( k2diff < - number ) ; 
} else if ( k2diff ) { 
var1 -> f_master [ var1 -> n_master ] ++ ; 
} 
var1 -> f_master [ number ] = var1 -> var2 [ number ] ; 
for ( var2 = number ; var2 <= var1 -> n_master ; var2 ++ ) 
var1 -> f_master [ var2 ] += var1 -> f_master [ var2 - number ] ; 
} else { 
int half_bands = number - spectrum -> bs_freq_scale ; 
int two_regions , num_bands_0 ; 
int vdk0_max , vdk1_min ; 
int16_t vk0 [ 49 ] ; 
int tmp , nz = number ; 
if ( 49 * var1 -> var2 [ 2 ] > 110 * var1 -> var2 [ number ] ) { 
two_regions = number ; 
var1 -> var2 [ number ] = 2 * var1 -> var2 [ number ] ; 
} else { 
two_regions = number ; 
var1 -> var2 [ number ] = var1 -> var2 [ 2 ] ; 
} 
tmp = ( var1 -> var2 [ number ] << number ) / var1 -> var2 [ number ] ; 
while ( tmp < 0x40000000 ) { 
tmp <<= number ; 
nz ++ ; 
} 
tmp = fixed_log ( tmp - 0x80000000 ) ; 
tmp = ( int ) ( ( ( int64_t ) tmp * CONST_RECIP_LN2 + 0x20000000 ) >> 30 ) ; 
tmp = ( ( ( tmp + 0x80 ) >> 8 ) + ( ( 8 - nz ) << number ) ) * half_bands ; 
num_bands_0 = ( ( tmp + 0x400000 ) >> number ) * 2 ; 
num_bands_0 = lrintf ( half_bands * log2f ( var1 -> var2 [ number ] / ( float ) var1 -> var2 [ number ] ) ) * 2 ; 
if ( num_bands_0 <= number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , num_bands_0 ) ; 
return - number ; 
} 
vk0 [ number ] = number ; 
make_bands ( vk0 + number , var1 -> var2 [ number ] , var1 -> var2 [ number ] , num_bands_0 ) ; 
qsort ( vk0 + number , num_bands_0 , sizeof ( vk0 [ number ] ) , var15 ) ; 
vdk0_max = vk0 [ num_bands_0 ] ; 
vk0 [ number ] = var1 -> var2 [ number ] ; 
for ( var2 = number ; var2 <= num_bands_0 ; var2 ++ ) { 
if ( vk0 [ var2 ] <= number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , var2 , vk0 [ var2 ] ) ; 
return - number ; 
} 
vk0 [ var2 ] += vk0 [ var2 - number ] ; 
} 
if ( two_regions ) { 
int16_t vk1 [ 49 ] ; 
int num_bands_1 ; 
tmp = ( var1 -> var2 [ 2 ] << number ) / var1 -> var2 [ number ] ; 
nz = number ; 
while ( tmp < 0x40000000 ) { 
tmp <<= number ; 
nz ++ ; 
} 
tmp = fixed_log ( tmp - 0x80000000 ) ; 
tmp = ( int ) ( ( ( int64_t ) tmp * CONST_RECIP_LN2 + 0x20000000 ) >> 30 ) ; 
tmp = ( ( ( tmp + 0x80 ) >> 8 ) + ( ( 8 - nz ) << number ) ) * half_bands ; 
if ( spectrum -> bs_alter_scale ) 
tmp = ( int ) ( ( ( int64_t ) tmp * CONST_076923 + 0x40000000 ) >> 31 ) ; 
num_bands_1 = ( ( tmp + 0x400000 ) >> number ) * 2 ; 
float invwarp = spectrum -> bs_alter_scale ? number . 76923076923076923077f 
: number . 0f ; 
int num_bands_1 = lrintf ( half_bands * invwarp * 
log2f ( var1 -> var2 [ 2 ] / ( float ) var1 -> var2 [ number ] ) ) * 2 ; 
make_bands ( vk1 + number , var1 -> var2 [ number ] , var1 -> var2 [ 2 ] , num_bands_1 ) ; 
vdk1_min = array_min_int16 ( vk1 + number , num_bands_1 ) ; 
if ( vdk1_min < vdk0_max ) { 
int change ; 
qsort ( vk1 + number , num_bands_1 , sizeof ( vk1 [ number ] ) , var15 ) ; 
change = FFMIN ( vdk0_max - vk1 [ number ] , ( vk1 [ num_bands_1 ] - vk1 [ number ] ) >> number ) ; 
vk1 [ number ] += change ; 
vk1 [ num_bands_1 ] -= change ; 
} 
qsort ( vk1 + number , num_bands_1 , sizeof ( vk1 [ number ] ) , var15 ) ; 
vk1 [ number ] = var1 -> var2 [ number ] ; 
for ( var2 = number ; var2 <= num_bands_1 ; var2 ++ ) { 
if ( vk1 [ var2 ] <= number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , var2 , vk1 [ var2 ] ) ; 
return - number ; 
} 
vk1 [ var2 ] += vk1 [ var2 - number ] ; 
} 
var1 -> n_master = num_bands_0 + num_bands_1 ; 
if ( check_n_master ( ac -> avctx , var1 -> n_master , var1 -> spectrum_params . bs_xover_band ) ) 
return - number ; 
memcpy ( & var1 -> f_master [ number ] , vk0 , 
( num_bands_0 + number ) * sizeof ( var1 -> f_master [ number ] ) ) ; 
memcpy ( & var1 -> f_master [ num_bands_0 + number ] , vk1 + number , 
num_bands_1 * sizeof ( var1 -> f_master [ number ] ) ) ; 
} else { 
var1 -> n_master = num_bands_0 ; 
if ( check_n_master ( ac -> avctx , var1 -> n_master , var1 -> spectrum_params . bs_xover_band ) ) 
return - number ; 
memcpy ( var1 -> f_master , vk0 , ( num_bands_0 + number ) * sizeof ( var1 -> f_master [ number ] ) ) ; 
} 
} 
return number ; 
} 
static int sbr_hf_calc_npatches ( AACContext * ac , SpectralBandReplication * var1 ) 
{ 
int i , var2 , last_k = - number , last_msb = - number , sb = number ; 
int msb = var1 -> var2 [ number ] ; 
int usb = var1 -> var10 [ number ] ; 
int goal_sb = ( ( 1000 << 11 ) + ( var1 -> sample_rate >> number ) ) / var1 -> sample_rate ; 
var1 -> var11 = number ; 
if ( goal_sb < var1 -> var10 [ number ] + var1 -> m [ number ] ) { 
for ( var2 = number ; var1 -> f_master [ var2 ] < goal_sb ; var2 ++ ) ; 
} else 
var2 = var1 -> n_master ; 
do { 
int odd = number ; 
if ( var2 == last_k && msb == last_msb ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str ) ; 
return AVERROR_INVALIDDATA ; 
} 
last_k = var2 ; 
last_msb = msb ; 
for ( i = var2 ; i == var2 || sb > ( var1 -> var2 [ number ] - number + msb - odd ) ; i -- ) { 
sb = var1 -> f_master [ i ] ; 
odd = ( sb + var1 -> var2 [ number ] ) & number ; 
} 
if ( var1 -> var11 > 5 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , var1 -> var11 ) ; 
return - number ; 
} 
var1 -> var12 [ var1 -> var11 ] = FFMAX ( sb - usb , number ) ; 
var1 -> patch_start_subband [ var1 -> var11 ] = var1 -> var2 [ number ] - odd - var1 -> var12 [ var1 -> var11 ] ; 
if ( var1 -> var12 [ var1 -> var11 ] > number ) { 
usb = sb ; 
msb = sb ; 
var1 -> var11 ++ ; 
} else 
msb = var1 -> var10 [ number ] ; 
if ( var1 -> f_master [ var2 ] - sb < number ) 
var2 = var1 -> n_master ; 
} while ( sb != var1 -> var10 [ number ] + var1 -> m [ number ] ) ; 
if ( var1 -> var11 > number && 
var1 -> var12 [ var1 -> var11 - number ] < number ) 
var1 -> var11 -- ; 
return number ; 
} 
static int sbr_make_f_derived ( AACContext * ac , SpectralBandReplication * var1 ) 
{ 
int var2 , temp ; 
int nz = number ; 
var1 -> var14 [ number ] = var1 -> n_master - var1 -> spectrum_params . bs_xover_band ; 
var1 -> var14 [ number ] = ( var1 -> var14 [ number ] + number ) >> number ; 
memcpy ( var1 -> f_tablehigh , & var1 -> f_master [ var1 -> spectrum_params . bs_xover_band ] , 
( var1 -> var14 [ number ] + number ) * sizeof ( var1 -> f_master [ number ] ) ) ; 
var1 -> m [ number ] = var1 -> f_tablehigh [ var1 -> var14 [ number ] ] - var1 -> f_tablehigh [ number ] ; 
var1 -> var10 [ number ] = var1 -> f_tablehigh [ number ] ; 
if ( var1 -> var10 [ number ] + var1 -> m [ number ] > 64 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , var1 -> var10 [ number ] + var1 -> m [ number ] ) ; 
return - number ; 
} 
if ( var1 -> var10 [ number ] > 32 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , var1 -> var10 [ number ] ) ; 
return - number ; 
} 
var1 -> var13 [ number ] = var1 -> f_tablehigh [ number ] ; 
temp = var1 -> var14 [ number ] & number ; 
for ( var2 = number ; var2 <= var1 -> var14 [ number ] ; var2 ++ ) 
var1 -> var13 [ var2 ] = var1 -> f_tablehigh [ 2 * var2 - temp ] ; 
temp = ( var1 -> var2 [ 2 ] << number ) / var1 -> var10 [ number ] ; 
while ( temp < 0x40000000 ) { 
temp <<= number ; 
nz ++ ; 
} 
temp = fixed_log ( temp - 0x80000000 ) ; 
temp = ( int ) ( ( ( int64_t ) temp * CONST_RECIP_LN2 + 0x20000000 ) >> 30 ) ; 
temp = ( ( ( temp + 0x80 ) >> 8 ) + ( ( 8 - nz ) << number ) ) * var1 -> spectrum_params . bs_noise_bands ; 
var1 -> n_q = ( temp + 0x400000 ) >> number ; 
if ( var1 -> n_q < number ) 
var1 -> n_q = number ; 
var1 -> n_q = FFMAX ( number , lrintf ( var1 -> spectrum_params . bs_noise_bands * 
log2f ( var1 -> var2 [ 2 ] / ( float ) var1 -> var10 [ number ] ) ) ) ; 
if ( var1 -> n_q > 5 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str , var1 -> n_q ) ; 
return - number ; 
} 
var1 -> f_tablenoise [ number ] = var1 -> var13 [ number ] ; 
temp = number ; 
for ( var2 = number ; var2 <= var1 -> n_q ; var2 ++ ) { 
temp += ( var1 -> var14 [ number ] - temp ) / ( var1 -> n_q + number - var2 ) ; 
var1 -> f_tablenoise [ var2 ] = var1 -> var13 [ temp ] ; 
} 
if ( sbr_hf_calc_npatches ( ac , var1 ) < number ) 
return - number ; 
func1 ( var1 ) ; 
var1 -> data [ number ] . f_indexnoise = number ; 
var1 -> data [ number ] . f_indexnoise = number ; 
return number ; 
} 
static av_always_inline void get_bits1_vector ( GetBitContext * gb , uint8_t * vec , 
int elements ) 
{ 
int i ; 
for ( i = number ; i < elements ; i ++ ) { 
vec [ i ] = get_bits1 ( gb ) ; 
} 
} 
static const int8_t ceil_log2 [ ] = { 
number , number , 2 , 2 , number , number , 
} ; 
static int read_sbr_grid ( AACContext * ac , SpectralBandReplication * var1 , 
GetBitContext * gb , SBRData * ch_data ) 
{ 
int i ; 
int bs_pointer = number ; 
int abs_bord_trail = 16 ; 
int num_rel_lead , num_rel_trail ; 
unsigned bs_num_env_old = ch_data -> bs_num_env ; 
ch_data -> bs_freq_res [ number ] = ch_data -> bs_freq_res [ ch_data -> bs_num_env ] ; 
ch_data -> bs_amp_res = var1 -> bs_amp_res_header ; 
ch_data -> t_env_num_env_old = ch_data -> t_env [ bs_num_env_old ] ; 
switch ( ch_data -> bs_frame_class = get_bits ( gb , 2 ) ) { 
case FIXFIX : 
ch_data -> bs_num_env = number << get_bits ( gb , 2 ) ; 
num_rel_lead = ch_data -> bs_num_env - number ; 
if ( ch_data -> bs_num_env == number ) 
ch_data -> bs_amp_res = number ; 
if ( ch_data -> bs_num_env > 4 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , 
ch_data -> bs_num_env ) ; 
return - number ; 
} 
ch_data -> t_env [ number ] = number ; 
ch_data -> t_env [ ch_data -> bs_num_env ] = abs_bord_trail ; 
abs_bord_trail = ( abs_bord_trail + ( ch_data -> bs_num_env >> number ) ) / 
ch_data -> bs_num_env ; 
for ( i = number ; i < num_rel_lead ; i ++ ) 
ch_data -> t_env [ i + number ] = ch_data -> t_env [ i ] + abs_bord_trail ; 
ch_data -> bs_freq_res [ number ] = get_bits1 ( gb ) ; 
for ( i = number ; i < ch_data -> bs_num_env ; i ++ ) 
ch_data -> bs_freq_res [ i + number ] = ch_data -> bs_freq_res [ number ] ; 
break ; 
case FIXVAR : 
abs_bord_trail += get_bits ( gb , 2 ) ; 
num_rel_trail = get_bits ( gb , 2 ) ; 
ch_data -> bs_num_env = num_rel_trail + number ; 
ch_data -> t_env [ number ] = number ; 
ch_data -> t_env [ ch_data -> bs_num_env ] = abs_bord_trail ; 
for ( i = number ; i < num_rel_trail ; i ++ ) 
ch_data -> t_env [ ch_data -> bs_num_env - number - i ] = 
ch_data -> t_env [ ch_data -> bs_num_env - i ] - 2 * get_bits ( gb , 2 ) - 2 ; 
bs_pointer = get_bits ( gb , ceil_log2 [ ch_data -> bs_num_env ] ) ; 
for ( i = number ; i < ch_data -> bs_num_env ; i ++ ) 
ch_data -> bs_freq_res [ ch_data -> bs_num_env - i ] = get_bits1 ( gb ) ; 
break ; 
case VARFIX : 
ch_data -> t_env [ number ] = get_bits ( gb , 2 ) ; 
num_rel_lead = get_bits ( gb , 2 ) ; 
ch_data -> bs_num_env = num_rel_lead + number ; 
ch_data -> t_env [ ch_data -> bs_num_env ] = abs_bord_trail ; 
for ( i = number ; i < num_rel_lead ; i ++ ) 
ch_data -> t_env [ i + number ] = ch_data -> t_env [ i ] + 2 * get_bits ( gb , 2 ) + 2 ; 
bs_pointer = get_bits ( gb , ceil_log2 [ ch_data -> bs_num_env ] ) ; 
get_bits1_vector ( gb , ch_data -> bs_freq_res + number , ch_data -> bs_num_env ) ; 
break ; 
case VARVAR : 
ch_data -> t_env [ number ] = get_bits ( gb , 2 ) ; 
abs_bord_trail += get_bits ( gb , 2 ) ; 
num_rel_lead = get_bits ( gb , 2 ) ; 
num_rel_trail = get_bits ( gb , 2 ) ; 
ch_data -> bs_num_env = num_rel_lead + num_rel_trail + number ; 
if ( ch_data -> bs_num_env > 5 ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , 
ch_data -> bs_num_env ) ; 
return - number ; 
} 
ch_data -> t_env [ ch_data -> bs_num_env ] = abs_bord_trail ; 
for ( i = number ; i < num_rel_lead ; i ++ ) 
ch_data -> t_env [ i + number ] = ch_data -> t_env [ i ] + 2 * get_bits ( gb , 2 ) + 2 ; 
for ( i = number ; i < num_rel_trail ; i ++ ) 
ch_data -> t_env [ ch_data -> bs_num_env - number - i ] = 
ch_data -> t_env [ ch_data -> bs_num_env - i ] - 2 * get_bits ( gb , 2 ) - 2 ; 
bs_pointer = get_bits ( gb , ceil_log2 [ ch_data -> bs_num_env ] ) ; 
get_bits1_vector ( gb , ch_data -> bs_freq_res + number , ch_data -> bs_num_env ) ; 
break ; 
} 
av_assert0 ( bs_pointer >= number ) ; 
if ( bs_pointer > ch_data -> bs_num_env + number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , 
bs_pointer ) ; 
return - number ; 
} 
for ( i = number ; i <= ch_data -> bs_num_env ; i ++ ) { 
if ( ch_data -> t_env [ i - number ] > ch_data -> t_env [ i ] ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str ) ; 
return - number ; 
} 
} 
ch_data -> bs_num_noise = ( ch_data -> bs_num_env > number ) + number ; 
ch_data -> t_q [ number ] = ch_data -> t_env [ number ] ; 
ch_data -> t_q [ ch_data -> bs_num_noise ] = ch_data -> t_env [ ch_data -> bs_num_env ] ; 
if ( ch_data -> bs_num_noise > number ) { 
int idx ; 
if ( ch_data -> bs_frame_class == FIXFIX ) { 
idx = ch_data -> bs_num_env >> number ; 
} else if ( ch_data -> bs_frame_class & number ) { 
idx = ch_data -> bs_num_env - FFMAX ( bs_pointer - number , number ) ; 
} else { 
if ( ! bs_pointer ) 
idx = number ; 
else if ( bs_pointer == number ) 
idx = ch_data -> bs_num_env - number ; 
else 
idx = bs_pointer - number ; 
} 
ch_data -> t_q [ number ] = ch_data -> t_env [ idx ] ; 
} 
ch_data -> e_a [ number ] = - ( ch_data -> e_a [ number ] != bs_num_env_old ) ; 
ch_data -> e_a [ number ] = - number ; 
if ( ( ch_data -> bs_frame_class & number ) && bs_pointer ) { 
ch_data -> e_a [ number ] = ch_data -> bs_num_env + number - bs_pointer ; 
} else if ( ( ch_data -> bs_frame_class == 2 ) && ( bs_pointer > number ) ) 
ch_data -> e_a [ number ] = bs_pointer - number ; 
return number ; 
} 
static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) { 
dst -> bs_freq_res [ number ] = dst -> bs_freq_res [ dst -> bs_num_env ] ; 
dst -> t_env_num_env_old = dst -> t_env [ dst -> bs_num_env ] ; 
dst -> e_a [ number ] = - ( dst -> e_a [ number ] != dst -> bs_num_env ) ; 
memcpy ( dst -> bs_freq_res + number , src -> bs_freq_res + number , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ; 
memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ; 
memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ; 
dst -> bs_num_env = src -> bs_num_env ; 
dst -> bs_amp_res = src -> bs_amp_res ; 
dst -> bs_num_noise = src -> bs_num_noise ; 
dst -> bs_frame_class = src -> bs_frame_class ; 
dst -> e_a [ number ] = src -> e_a [ number ] ; 
} 
static void read_sbr_dtdf ( SpectralBandReplication * var1 , GetBitContext * gb , 
SBRData * ch_data ) 
{ 
get_bits1_vector ( gb , ch_data -> bs_df_env , ch_data -> bs_num_env ) ; 
get_bits1_vector ( gb , ch_data -> bs_df_noise , ch_data -> bs_num_noise ) ; 
} 
static void read_sbr_invf ( SpectralBandReplication * var1 , GetBitContext * gb , 
SBRData * ch_data ) 
{ 
int i ; 
memcpy ( ch_data -> bs_invf_mode [ number ] , ch_data -> bs_invf_mode [ number ] , 5 * sizeof ( uint8_t ) ) ; 
for ( i = number ; i < var1 -> n_q ; i ++ ) 
ch_data -> bs_invf_mode [ number ] [ i ] = get_bits ( gb , 2 ) ; 
} 
static void read_sbr_envelope ( SpectralBandReplication * var1 , GetBitContext * gb , 
SBRData * ch_data , int ch ) 
{ 
int bits ; 
int i , j , var2 ; 
VLC_TYPE ( * t_huff ) [ 2 ] , ( * f_huff ) [ 2 ] ; 
int t_lav , f_lav ; 
const int delta = ( ch == number && var1 -> bs_coupling == number ) + number ; 
const int odd = var1 -> var14 [ number ] & number ; 
if ( var1 -> bs_coupling && ch ) { 
if ( ch_data -> bs_amp_res ) { 
bits = 5 ; 
t_huff = vlc_sbr [ T_HUFFMAN_ENV_BAL_3_0DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_BAL_3_0DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_3_0DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_3_0DB ] ; 
} else { 
bits = 6 ; 
t_huff = vlc_sbr [ T_HUFFMAN_ENV_BAL_1_5DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_BAL_1_5DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_1_5DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_1_5DB ] ; 
} 
} else { 
if ( ch_data -> bs_amp_res ) { 
bits = 6 ; 
t_huff = vlc_sbr [ T_HUFFMAN_ENV_3_0DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_3_0DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_3_0DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_3_0DB ] ; 
} else { 
bits = number ; 
t_huff = vlc_sbr [ T_HUFFMAN_ENV_1_5DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_1_5DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_1_5DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_1_5DB ] ; 
} 
} 
for ( i = number ; i < ch_data -> bs_num_env ; i ++ ) { 
if ( ch_data -> bs_df_env [ i ] ) { 
if ( ch_data -> bs_freq_res [ i + number ] == ch_data -> bs_freq_res [ i ] ) { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) 
ch_data -> env_facs [ i + number ] [ j ] . mant = ch_data -> env_facs [ i ] [ j ] . mant + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} else if ( ch_data -> bs_freq_res [ i + number ] ) { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) { 
var2 = ( j + odd ) >> number ; 
ch_data -> env_facs [ i + number ] [ j ] . mant = ch_data -> env_facs [ i ] [ var2 ] . mant + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} 
} else { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) { 
var2 = j ? 2 * j - odd : number ; 
ch_data -> env_facs [ i + number ] [ j ] . mant = ch_data -> env_facs [ i ] [ var2 ] . mant + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} 
} 
} else { 
ch_data -> env_facs [ i + number ] [ number ] . mant = delta * get_bits ( gb , bits ) ; 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) 
ch_data -> env_facs [ i + number ] [ j ] . mant = ch_data -> env_facs [ i + number ] [ j - number ] . mant + delta * ( get_vlc2 ( gb , f_huff , 9 , number ) - f_lav ) ; 
} 
} 
for ( i = number ; i < ch_data -> bs_num_env ; i ++ ) { 
if ( ch_data -> bs_df_env [ i ] ) { 
if ( ch_data -> bs_freq_res [ i + number ] == ch_data -> bs_freq_res [ i ] ) { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) 
ch_data -> env_facs [ i + number ] [ j ] = ch_data -> env_facs [ i ] [ j ] + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} else if ( ch_data -> bs_freq_res [ i + number ] ) { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) { 
var2 = ( j + odd ) >> number ; 
ch_data -> env_facs [ i + number ] [ j ] = ch_data -> env_facs [ i ] [ var2 ] + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} 
} else { 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) { 
var2 = j ? 2 * j - odd : number ; 
ch_data -> env_facs [ i + number ] [ j ] = ch_data -> env_facs [ i ] [ var2 ] + delta * ( get_vlc2 ( gb , t_huff , 9 , number ) - t_lav ) ; 
} 
} 
} else { 
ch_data -> env_facs [ i + number ] [ number ] = delta * get_bits ( gb , bits ) ; 
for ( j = number ; j < var1 -> var14 [ ch_data -> bs_freq_res [ i + number ] ] ; j ++ ) 
ch_data -> env_facs [ i + number ] [ j ] = ch_data -> env_facs [ i + number ] [ j - number ] + delta * ( get_vlc2 ( gb , f_huff , 9 , number ) - f_lav ) ; 
} 
} 
memcpy ( ch_data -> env_facs [ number ] , ch_data -> env_facs [ ch_data -> bs_num_env ] , 
sizeof ( ch_data -> env_facs [ number ] ) ) ; 
} 
static void read_sbr_noise ( SpectralBandReplication * var1 , GetBitContext * gb , 
SBRData * ch_data , int ch ) 
{ 
int i , j ; 
VLC_TYPE ( * t_huff ) [ 2 ] , ( * f_huff ) [ 2 ] ; 
int t_lav , f_lav ; 
int delta = ( ch == number && var1 -> bs_coupling == number ) + number ; 
if ( var1 -> bs_coupling && ch ) { 
t_huff = vlc_sbr [ T_HUFFMAN_NOISE_BAL_3_0DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_NOISE_BAL_3_0DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_3_0DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_3_0DB ] ; 
} else { 
t_huff = vlc_sbr [ T_HUFFMAN_NOISE_3_0DB ] . table ; 
t_lav = vlc_sbr_lav [ T_HUFFMAN_NOISE_3_0DB ] ; 
f_huff = vlc_sbr [ F_HUFFMAN_ENV_3_0DB ] . table ; 
f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_3_0DB ] ; 
} 
for ( i = number ; i < ch_data -> bs_num_noise ; i ++ ) { 
if ( ch_data -> bs_df_noise [ i ] ) { 
for ( j = number ; j < var1 -> n_q ; j ++ ) 
ch_data -> noise_facs [ i + number ] [ j ] . mant = ch_data -> noise_facs [ i ] [ j ] . mant + delta * ( get_vlc2 ( gb , t_huff , 9 , 2 ) - t_lav ) ; 
} else { 
ch_data -> noise_facs [ i + number ] [ number ] . mant = delta * get_bits ( gb , 5 ) ; 
for ( j = number ; j < var1 -> n_q ; j ++ ) 
ch_data -> noise_facs [ i + number ] [ j ] . mant = ch_data -> noise_facs [ i + number ] [ j - number ] . mant + delta * ( get_vlc2 ( gb , f_huff , 9 , number ) - f_lav ) ; 
} 
} 
for ( i = number ; i < ch_data -> bs_num_noise ; i ++ ) { 
if ( ch_data -> bs_df_noise [ i ] ) { 
for ( j = number ; j < var1 -> n_q ; j ++ ) 
ch_data -> noise_facs [ i + number ] [ j ] = ch_data -> noise_facs [ i ] [ j ] + delta * ( get_vlc2 ( gb , t_huff , 9 , 2 ) - t_lav ) ; 
} else { 
ch_data -> noise_facs [ i + number ] [ number ] = delta * get_bits ( gb , 5 ) ; 
for ( j = number ; j < var1 -> n_q ; j ++ ) 
ch_data -> noise_facs [ i + number ] [ j ] = ch_data -> noise_facs [ i + number ] [ j - number ] + delta * ( get_vlc2 ( gb , f_huff , 9 , number ) - f_lav ) ; 
} 
} 
memcpy ( ch_data -> noise_facs [ number ] , ch_data -> noise_facs [ ch_data -> bs_num_noise ] , 
sizeof ( ch_data -> noise_facs [ number ] ) ) ; 
} 
static void read_sbr_extension ( AACContext * ac , SpectralBandReplication * var1 , 
GetBitContext * gb , 
int bs_extension_id , int * num_bits_left ) 
{ 
switch ( bs_extension_id ) { 
case EXTENSION_ID_PS : 
if ( ! ac -> oc [ number ] . m4ac . ps ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str ) ; 
skip_bits_long ( gb , * num_bits_left ) ; 
* num_bits_left = number ; 
} else { 
* num_bits_left -= AAC_RENAME ( ff_ps_read_data ) ( ac -> avctx , gb , & var1 -> ps , * num_bits_left ) ; 
ac -> avctx -> profile = FF_PROFILE_AAC_HE_V2 ; 
avpriv_report_missing_feature ( ac -> avctx , str ) ; 
skip_bits_long ( gb , * num_bits_left ) ; 
* num_bits_left = number ; 
} 
break ; 
default : 
if ( bs_extension_id || * num_bits_left > 16 || show_bits ( gb , * num_bits_left ) ) 
avpriv_request_sample ( ac -> avctx , str ) ; 
skip_bits_long ( gb , * num_bits_left ) ; 
* num_bits_left = number ; 
break ; 
} 
} 
static int read_sbr_single_channel_element ( AACContext * ac , 
SpectralBandReplication * var1 , 
GetBitContext * gb ) 
{ 
if ( get_bits1 ( gb ) ) 
skip_bits ( gb , 4 ) ; 
if ( read_sbr_grid ( ac , var1 , gb , & var1 -> data [ number ] ) ) 
return - number ; 
read_sbr_dtdf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_invf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_envelope ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_noise ( var1 , gb , & var1 -> data [ number ] , number ) ; 
if ( ( var1 -> data [ number ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) 
get_bits1_vector ( gb , var1 -> data [ number ] . bs_add_harmonic , var1 -> var14 [ number ] ) ; 
return number ; 
} 
static int read_sbr_channel_pair_element ( AACContext * ac , 
SpectralBandReplication * var1 , 
GetBitContext * gb ) 
{ 
if ( get_bits1 ( gb ) ) 
skip_bits ( gb , 8 ) ; 
if ( ( var1 -> bs_coupling = get_bits1 ( gb ) ) ) { 
if ( read_sbr_grid ( ac , var1 , gb , & var1 -> data [ number ] ) ) 
return - number ; 
copy_sbr_grid ( & var1 -> data [ number ] , & var1 -> data [ number ] ) ; 
read_sbr_dtdf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_dtdf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_invf ( var1 , gb , & var1 -> data [ number ] ) ; 
memcpy ( var1 -> data [ number ] . bs_invf_mode [ number ] , var1 -> data [ number ] . bs_invf_mode [ number ] , sizeof ( var1 -> data [ number ] . bs_invf_mode [ number ] ) ) ; 
memcpy ( var1 -> data [ number ] . bs_invf_mode [ number ] , var1 -> data [ number ] . bs_invf_mode [ number ] , sizeof ( var1 -> data [ number ] . bs_invf_mode [ number ] ) ) ; 
read_sbr_envelope ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_noise ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_envelope ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_noise ( var1 , gb , & var1 -> data [ number ] , number ) ; 
} else { 
if ( read_sbr_grid ( ac , var1 , gb , & var1 -> data [ number ] ) || 
read_sbr_grid ( ac , var1 , gb , & var1 -> data [ number ] ) ) 
return - number ; 
read_sbr_dtdf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_dtdf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_invf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_invf ( var1 , gb , & var1 -> data [ number ] ) ; 
read_sbr_envelope ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_envelope ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_noise ( var1 , gb , & var1 -> data [ number ] , number ) ; 
read_sbr_noise ( var1 , gb , & var1 -> data [ number ] , number ) ; 
} 
if ( ( var1 -> data [ number ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) 
get_bits1_vector ( gb , var1 -> data [ number ] . bs_add_harmonic , var1 -> var14 [ number ] ) ; 
if ( ( var1 -> data [ number ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) 
get_bits1_vector ( gb , var1 -> data [ number ] . bs_add_harmonic , var1 -> var14 [ number ] ) ; 
return number ; 
} 
static unsigned int read_sbr_data ( AACContext * ac , SpectralBandReplication * var1 , 
GetBitContext * gb , int id_aac ) 
{ 
unsigned int cnt = get_bits_count ( gb ) ; 
var1 -> id_aac = id_aac ; 
if ( id_aac == TYPE_SCE || id_aac == TYPE_CCE ) { 
if ( read_sbr_single_channel_element ( ac , var1 , gb ) ) { 
sbr_turnoff ( var1 ) ; 
return get_bits_count ( gb ) - cnt ; 
} 
} else if ( id_aac == TYPE_CPE ) { 
if ( read_sbr_channel_pair_element ( ac , var1 , gb ) ) { 
sbr_turnoff ( var1 ) ; 
return get_bits_count ( gb ) - cnt ; 
} 
} else { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , id_aac ) ; 
sbr_turnoff ( var1 ) ; 
return get_bits_count ( gb ) - cnt ; 
} 
if ( get_bits1 ( gb ) ) { 
int num_bits_left = get_bits ( gb , 4 ) ; 
if ( num_bits_left == 15 ) 
num_bits_left += get_bits ( gb , 8 ) ; 
num_bits_left <<= number ; 
while ( num_bits_left > number ) { 
num_bits_left -= 2 ; 
read_sbr_extension ( ac , var1 , gb , get_bits ( gb , 2 ) , & num_bits_left ) ; 
} 
if ( num_bits_left < number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str ) ; 
} 
if ( num_bits_left > number ) 
skip_bits ( gb , num_bits_left ) ; 
} 
return get_bits_count ( gb ) - cnt ; 
} 
static void sbr_reset ( AACContext * ac , SpectralBandReplication * var1 ) 
{ 
int err ; 
err = sbr_make_f_master ( ac , var1 , & var1 -> spectrum_params ) ; 
if ( err >= number ) 
err = sbr_make_f_derived ( ac , var1 ) ; 
if ( err < number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str ) ; 
sbr_turnoff ( var1 ) ; 
} 
} 
int AAC_RENAME ( ff_decode_sbr_extension ) ( AACContext * ac , SpectralBandReplication * var1 , 
GetBitContext * gb_host , int crc , int cnt , int id_aac ) 
{ 
unsigned int num_sbr_bits = number , num_align_bits ; 
unsigned bytes_read ; 
GetBitContext gbc = * gb_host , * gb = & gbc ; 
skip_bits_long ( gb_host , cnt * 8 - 4 ) ; 
var1 -> reset = number ; 
if ( ! var1 -> sample_rate ) 
var1 -> sample_rate = 2 * ac -> oc [ number ] . m4ac . sample_rate ; 
if ( ! ac -> oc [ number ] . m4ac . ext_sample_rate ) 
ac -> oc [ number ] . m4ac . ext_sample_rate = 2 * ac -> oc [ number ] . m4ac . sample_rate ; 
if ( crc ) { 
skip_bits ( gb , 10 ) ; 
num_sbr_bits += 10 ; 
} 
var1 -> var10 [ number ] = var1 -> var10 [ number ] ; 
var1 -> m [ number ] = var1 -> m [ number ] ; 
var1 -> kx_and_m_pushed = number ; 
num_sbr_bits ++ ; 
if ( get_bits1 ( gb ) ) 
num_sbr_bits += read_sbr_header ( var1 , gb ) ; 
if ( var1 -> reset ) 
sbr_reset ( ac , var1 ) ; 
if ( var1 -> start ) 
num_sbr_bits += read_sbr_data ( ac , var1 , gb , id_aac ) ; 
num_align_bits = ( ( cnt << number ) - 4 - num_sbr_bits ) & number ; 
bytes_read = ( ( num_sbr_bits + num_align_bits + 4 ) >> number ) ; 
if ( bytes_read > cnt ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , cnt , bytes_read ) ; 
} 
return cnt ; 
} 
static void sbr_qmf_analysis ( AVFixedDSPContext * dsp , FFTContext * mdct , 
static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , 
SBRDSPContext * sbrdsp , const INTFLOAT * var7 , INTFLOAT * x , 
INTFLOAT z [ 320 ] , INTFLOAT W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) 
{ 
int i ; 
memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ number ] ) ) ; 
memcpy ( x + 288 , var7 , 1024 * sizeof ( x [ number ] ) ) ; 
for ( i = number ; i < 32 ; i ++ ) { 
dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ; 
sbrdsp -> sum64x5 ( z ) ; 
sbrdsp -> qmf_pre_shuffle ( z ) ; 
mdct -> imdct_half ( mdct , z , z + 64 ) ; 
sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ; 
x += 32 ; 
} 
} 
static void sbr_qmf_synthesis ( FFTContext * mdct , 
SBRDSPContext * sbrdsp , AVFixedDSPContext * dsp , 
SBRDSPContext * sbrdsp , AVFloatDSPContext * dsp , 
INTFLOAT * var9 , INTFLOAT X [ 2 ] [ 38 ] [ 64 ] , 
INTFLOAT mdct_buf [ 2 ] [ 64 ] , 
INTFLOAT * v0 , int * v_off , const unsigned int div ) 
{ 
int i , var14 ; 
const INTFLOAT * sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us ; 
const int step = 128 >> div ; 
INTFLOAT * v ; 
for ( i = number ; i < 32 ; i ++ ) { 
if ( * v_off < step ) { 
int saved_samples = ( 1280 - 128 ) >> div ; 
memcpy ( & v0 [ SBR_SYNTHESIS_BUF_SIZE - saved_samples ] , v0 , saved_samples * sizeof ( INTFLOAT ) ) ; 
* v_off = SBR_SYNTHESIS_BUF_SIZE - saved_samples - step ; 
} else { 
* v_off -= step ; 
} 
v = v0 + * v_off ; 
if ( div ) { 
for ( var14 = number ; var14 < 32 ; var14 ++ ) { 
X [ number ] [ i ] [ var14 ] = - X [ number ] [ i ] [ var14 ] ; 
X [ number ] [ i ] [ 32 + var14 ] = X [ number ] [ i ] [ 31 - var14 ] ; 
} 
mdct -> imdct_half ( mdct , mdct_buf [ number ] , X [ number ] [ i ] ) ; 
sbrdsp -> qmf_deint_neg ( v , mdct_buf [ number ] ) ; 
} else { 
sbrdsp -> neg_odd_64 ( X [ number ] [ i ] ) ; 
mdct -> imdct_half ( mdct , mdct_buf [ number ] , X [ number ] [ i ] ) ; 
mdct -> imdct_half ( mdct , mdct_buf [ number ] , X [ number ] [ i ] ) ; 
sbrdsp -> qmf_deint_bfly ( v , mdct_buf [ number ] , mdct_buf [ number ] ) ; 
} 
dsp -> vector_fmul ( var9 , v , sbr_qmf_window , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 192 >> div ) , sbr_qmf_window + ( 64 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 256 >> div ) , sbr_qmf_window + ( 128 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 448 >> div ) , sbr_qmf_window + ( 192 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 512 >> div ) , sbr_qmf_window + ( 256 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 704 >> div ) , sbr_qmf_window + ( 320 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 768 >> div ) , sbr_qmf_window + ( 384 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 960 >> div ) , sbr_qmf_window + ( 448 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 1024 >> div ) , sbr_qmf_window + ( 512 >> div ) , var9 , 64 >> div ) ; 
dsp -> vector_fmul_add ( var9 , v + ( 1216 >> div ) , sbr_qmf_window + ( 576 >> div ) , var9 , 64 >> div ) ; 
var9 += 64 >> div ; 
} 
} 
static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * var1 , 
INTFLOAT X_low [ 32 ] [ 40 ] [ 2 ] , const INTFLOAT W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , 
int buf_idx ) 
{ 
int i , var2 ; 
const int t_HFGen = 8 ; 
const int i_f = 32 ; 
memset ( X_low , number , 32 * sizeof ( * X_low ) ) ; 
for ( var2 = number ; var2 < var1 -> var10 [ number ] ; var2 ++ ) { 
for ( i = t_HFGen ; i < i_f + t_HFGen ; i ++ ) { 
X_low [ var2 ] [ i ] [ number ] = W [ buf_idx ] [ i - t_HFGen ] [ var2 ] [ number ] ; 
X_low [ var2 ] [ i ] [ number ] = W [ buf_idx ] [ i - t_HFGen ] [ var2 ] [ number ] ; 
} 
} 
buf_idx = number - buf_idx ; 
for ( var2 = number ; var2 < var1 -> var10 [ number ] ; var2 ++ ) { 
for ( i = number ; i < t_HFGen ; i ++ ) { 
X_low [ var2 ] [ i ] [ number ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ var2 ] [ number ] ; 
X_low [ var2 ] [ i ] [ number ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ var2 ] [ number ] ; 
} 
} 
return number ; 
} 
static int sbr_hf_gen ( AACContext * ac , SpectralBandReplication * var1 , 
INTFLOAT X_high [ 64 ] [ 40 ] [ 2 ] , const INTFLOAT X_low [ 32 ] [ 40 ] [ 2 ] , 
const INTFLOAT ( * alpha0 ) [ 2 ] , const INTFLOAT ( * alpha1 ) [ 2 ] , 
const INTFLOAT bw_array [ 5 ] , const uint8_t * t_env , 
int bs_num_env ) 
{ 
int j , x ; 
int g = number ; 
int var2 = var1 -> var10 [ number ] ; 
for ( j = number ; j < var1 -> var11 ; j ++ ) { 
for ( x = number ; x < var1 -> var12 [ j ] ; x ++ , var2 ++ ) { 
const int p = var1 -> patch_start_subband [ j ] + x ; 
while ( g <= var1 -> n_q && var2 >= var1 -> f_tablenoise [ g ] ) 
g ++ ; 
g -- ; 
if ( g < number ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , var2 ) ; 
return - number ; 
} 
var1 -> dsp . hf_gen ( X_high [ var2 ] + ENVELOPE_ADJUSTMENT_OFFSET , 
X_low [ p ] + ENVELOPE_ADJUSTMENT_OFFSET , 
alpha0 [ p ] , alpha1 [ p ] , bw_array [ g ] , 
2 * t_env [ number ] , 2 * t_env [ bs_num_env ] ) ; 
} 
} 
if ( var2 < var1 -> m [ number ] + var1 -> var10 [ number ] ) 
memset ( X_high + var2 , number , ( var1 -> m [ number ] + var1 -> var10 [ number ] - var2 ) * sizeof ( * X_high ) ) ; 
return number ; 
} 
static int sbr_x_gen ( SpectralBandReplication * var1 , INTFLOAT X [ 2 ] [ 38 ] [ 64 ] , 
const INTFLOAT Y0 [ 38 ] [ 64 ] [ 2 ] , const INTFLOAT Y1 [ 38 ] [ 64 ] [ 2 ] , 
const INTFLOAT X_low [ 32 ] [ 40 ] [ 2 ] , int ch ) 
{ 
int var2 , i ; 
const int i_f = 32 ; 
const int i_Temp = FFMAX ( 2 * var1 -> data [ ch ] . t_env_num_env_old - i_f , number ) ; 
memset ( X , number , 2 * sizeof ( * X ) ) ; 
for ( var2 = number ; var2 < var1 -> var10 [ number ] ; var2 ++ ) { 
for ( i = number ; i < i_Temp ; i ++ ) { 
X [ number ] [ i ] [ var2 ] = X_low [ var2 ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ number ] ; 
X [ number ] [ i ] [ var2 ] = X_low [ var2 ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ number ] ; 
} 
} 
for ( ; var2 < var1 -> var10 [ number ] + var1 -> m [ number ] ; var2 ++ ) { 
for ( i = number ; i < i_Temp ; i ++ ) { 
X [ number ] [ i ] [ var2 ] = Y0 [ i + i_f ] [ var2 ] [ number ] ; 
X [ number ] [ i ] [ var2 ] = Y0 [ i + i_f ] [ var2 ] [ number ] ; 
} 
} 
for ( var2 = number ; var2 < var1 -> var10 [ number ] ; var2 ++ ) { 
for ( i = i_Temp ; i < 38 ; i ++ ) { 
X [ number ] [ i ] [ var2 ] = X_low [ var2 ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ number ] ; 
X [ number ] [ i ] [ var2 ] = X_low [ var2 ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ number ] ; 
} 
} 
for ( ; var2 < var1 -> var10 [ number ] + var1 -> m [ number ] ; var2 ++ ) { 
for ( i = i_Temp ; i < i_f ; i ++ ) { 
X [ number ] [ i ] [ var2 ] = Y1 [ i ] [ var2 ] [ number ] ; 
X [ number ] [ i ] [ var2 ] = Y1 [ i ] [ var2 ] [ number ] ; 
} 
} 
return number ; 
} 
static int sbr_mapping ( AACContext * ac , SpectralBandReplication * var1 , 
SBRData * ch_data , int e_a [ 2 ] ) 
{ 
int e , i , m ; 
memset ( ch_data -> s_indexmapped [ number ] , number , number * sizeof ( ch_data -> s_indexmapped [ number ] ) ) ; 
for ( e = number ; e < ch_data -> bs_num_env ; e ++ ) { 
const unsigned int ilim = var1 -> var14 [ ch_data -> bs_freq_res [ e + number ] ] ; 
uint16_t * table = ch_data -> bs_freq_res [ e + number ] ? var1 -> f_tablehigh : var1 -> var13 ; 
int var2 ; 
if ( var1 -> var10 [ number ] != table [ number ] ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , str 
str ) ; 
sbr_turnoff ( var1 ) ; 
return AVERROR_BUG ; 
} 
for ( i = number ; i < ilim ; i ++ ) 
for ( m = table [ i ] ; m < table [ i + number ] ; m ++ ) 
var1 -> e_origmapped [ e ] [ m - var1 -> var10 [ number ] ] = ch_data -> env_facs [ e + number ] [ i ] ; 
var2 = ( ch_data -> bs_num_noise > number ) && ( ch_data -> t_env [ e ] >= ch_data -> t_q [ number ] ) ; 
for ( i = number ; i < var1 -> n_q ; i ++ ) 
for ( m = var1 -> f_tablenoise [ i ] ; m < var1 -> f_tablenoise [ i + number ] ; m ++ ) 
var1 -> q_mapped [ e ] [ m - var1 -> var10 [ number ] ] = ch_data -> noise_facs [ var2 + number ] [ i ] ; 
for ( i = number ; i < var1 -> var14 [ number ] ; i ++ ) { 
if ( ch_data -> bs_add_harmonic_flag ) { 
const unsigned int m_midpoint = 
( var1 -> f_tablehigh [ i ] + var1 -> f_tablehigh [ i + number ] ) >> number ; 
ch_data -> s_indexmapped [ e + number ] [ m_midpoint - var1 -> var10 [ number ] ] = ch_data -> bs_add_harmonic [ i ] * 
( e >= e_a [ number ] || ( ch_data -> s_indexmapped [ number ] [ m_midpoint - var1 -> var10 [ number ] ] == number ) ) ; 
} 
} 
for ( i = number ; i < ilim ; i ++ ) { 
int additional_sinusoid_present = number ; 
for ( m = table [ i ] ; m < table [ i + number ] ; m ++ ) { 
if ( ch_data -> s_indexmapped [ e + number ] [ m - var1 -> var10 [ number ] ] ) { 
additional_sinusoid_present = number ; 
break ; 
} 
} 
memset ( & var1 -> s_mapped [ e ] [ table [ i ] - var1 -> var10 [ number ] ] , additional_sinusoid_present , 
( table [ i + number ] - table [ i ] ) * sizeof ( var1 -> s_mapped [ e ] [ number ] ) ) ; 
} 
} 
memcpy ( ch_data -> s_indexmapped [ number ] , ch_data -> s_indexmapped [ ch_data -> bs_num_env ] , sizeof ( ch_data -> s_indexmapped [ number ] ) ) ; 
return number ; 
} 
static void sbr_env_estimate ( AAC_FLOAT ( * e_curr ) [ 48 ] , INTFLOAT X_high [ 64 ] [ 40 ] [ 2 ] , 
SpectralBandReplication * var1 , SBRData * ch_data ) 
{ 
int e , m ; 
int kx1 = var1 -> var10 [ number ] ; 
if ( var1 -> bs_interpol_freq ) { 
for ( e = number ; e < ch_data -> bs_num_env ; e ++ ) { 
const SoftFloat recip_env_size = av_int2sf ( 0x20000000 / ( ch_data -> t_env [ e + number ] - ch_data -> t_env [ e ] ) , 30 ) ; 
const float recip_env_size = number . 5f / ( ch_data -> t_env [ e + number ] - ch_data -> t_env [ e ] ) ; 
int ilb = ch_data -> t_env [ e ] * 2 + ENVELOPE_ADJUSTMENT_OFFSET ; 
int iub = ch_data -> t_env [ e + number ] * 2 + ENVELOPE_ADJUSTMENT_OFFSET ; 
for ( m = number ; m < var1 -> m [ number ] ; m ++ ) { 
AAC_FLOAT sum = var1 -> dsp . sum_square ( X_high [ m + kx1 ] + ilb , iub - ilb ) ; 
e_curr [ e ] [ m ] = av_mul_sf ( sum , recip_env_size ) ; 
e_curr [ e ] [ m ] = sum * recip_env_size ; 
} 
} 
} else { 
int var2 , p ; 
for ( e = number ; e < ch_data -> bs_num_env ; e ++ ) { 
const int env_size = 2 * ( ch_data -> t_env [ e + number ] - ch_data -> t_env [ e ] ) ; 
int ilb = ch_data -> t_env [ e ] * 2 + ENVELOPE_ADJUSTMENT_OFFSET ; 
int iub = ch_data -> t_env [ e + number ] * 2 + ENVELOPE_ADJUSTMENT_OFFSET ; 
const uint16_t * table = ch_data -> bs_freq_res [ e + number ] ? var1 -> f_tablehigh : var1 -> var13 ; 
for ( p = number ; p < var1 -> var14 [ ch_data -> bs_freq_res [ e + number ] ] ; p ++ ) { 
SoftFloat sum = { number , number } ; 
const SoftFloat den = av_int2sf ( 0x20000000 / ( env_size * ( table [ p + number ] - table [ p ] ) ) , 29 ) ; 
for ( var2 = table [ p ] ; var2 < table [ p + number ] ; var2 ++ ) { 
sum = av_add_sf ( sum , var1 -> dsp . sum_square ( X_high [ var2 ] + ilb , iub - ilb ) ) ; 
} 
sum = av_mul_sf ( sum , den ) ; 
float sum = number . 0f ; 
const int den = env_size * ( table [ p + number ] - table [ p ] ) ; 
for ( var2 = table [ p ] ; var2 < table [ p + number ] ; var2 ++ ) { 
sum += var1 -> dsp . sum_square ( X_high [ var2 ] + ilb , iub - ilb ) ; 
} 
sum /= den ; 
for ( var2 = table [ p ] ; var2 < table [ p + number ] ; var2 ++ ) { 
e_curr [ e ] [ var2 - kx1 ] = sum ; 
} 
} 
} 
} 
} 
void AAC_RENAME ( ff_sbr_apply ) ( AACContext * ac , SpectralBandReplication * var1 , int id_aac , 
INTFLOAT * L , INTFLOAT * R ) 
{ 
int downsampled = ac -> oc [ number ] . m4ac . ext_sample_rate < var1 -> sample_rate ; 
int ch ; 
int nch = ( id_aac == TYPE_CPE ) ? 2 : number ; 
int err ; 
if ( id_aac != var1 -> id_aac ) { 
av_log ( ac -> avctx , AV_LOG_ERROR , 
str , id_aac , var1 -> id_aac ) ; 
sbr_turnoff ( var1 ) ; 
} 
if ( ! var1 -> kx_and_m_pushed ) { 
var1 -> var10 [ number ] = var1 -> var10 [ number ] ; 
var1 -> m [ number ] = var1 -> m [ number ] ; 
} else { 
var1 -> kx_and_m_pushed = number ; 
} 
if ( var1 -> start ) { 
sbr_dequant ( var1 , id_aac ) ; 
} 
for ( ch = number ; ch < nch ; ch ++ ) { 
sbr_qmf_analysis ( ac -> fdsp , & var1 -> mdct_ana , & var1 -> dsp , ch ? R : L , var1 -> data [ ch ] . analysis_filterbank_samples , 
( INTFLOAT * ) var1 -> qmf_filter_scratch , 
var1 -> data [ ch ] . W , var1 -> data [ ch ] . Ypos ) ; 
var1 -> c . sbr_lf_gen ( ac , var1 , var1 -> X_low , 
( const INTFLOAT ( * ) [ 32 ] [ 32 ] [ 2 ] ) var1 -> data [ ch ] . W , 
var1 -> data [ ch ] . Ypos ) ; 
var1 -> data [ ch ] . Ypos ^= number ; 
if ( var1 -> start ) { 
var1 -> c . sbr_hf_inverse_filter ( & var1 -> dsp , var1 -> alpha0 , var1 -> alpha1 , 
( const INTFLOAT ( * ) [ 40 ] [ 2 ] ) var1 -> X_low , var1 -> var2 [ number ] ) ; 
sbr_chirp ( var1 , & var1 -> data [ ch ] ) ; 
av_assert0 ( var1 -> data [ ch ] . bs_num_env > number ) ; 
sbr_hf_gen ( ac , var1 , var1 -> X_high , 
( const INTFLOAT ( * ) [ 40 ] [ 2 ] ) var1 -> X_low , 
( const INTFLOAT ( * ) [ 2 ] ) var1 -> alpha0 , 
( const INTFLOAT ( * ) [ 2 ] ) var1 -> alpha1 , 
var1 -> data [ ch ] . bw_array , var1 -> data [ ch ] . t_env , 
var1 -> data [ ch ] . bs_num_env ) ; 
err = sbr_mapping ( ac , var1 , & var1 -> data [ ch ] , var1 -> data [ ch ] . e_a ) ; 
if ( ! err ) { 
sbr_env_estimate ( var1 -> e_curr , var1 -> X_high , var1 , & var1 -> data [ ch ] ) ; 
sbr_gain_calc ( ac , var1 , & var1 -> data [ ch ] , var1 -> data [ ch ] . e_a ) ; 
var1 -> c . sbr_hf_assemble ( var1 -> data [ ch ] . Y [ var1 -> data [ ch ] . Ypos ] , 
( const INTFLOAT ( * ) [ 40 ] [ 2 ] ) var1 -> X_high , 
var1 , & var1 -> data [ ch ] , 
var1 -> data [ ch ] . e_a ) ; 
} 
} 
var1 -> c . sbr_x_gen ( var1 , var1 -> X [ ch ] , 
( const INTFLOAT ( * ) [ 64 ] [ 2 ] ) var1 -> data [ ch ] . Y [ number - var1 -> data [ ch ] . Ypos ] , 
( const INTFLOAT ( * ) [ 64 ] [ 2 ] ) var1 -> data [ ch ] . Y [ var1 -> data [ ch ] . Ypos ] , 
( const INTFLOAT ( * ) [ 40 ] [ 2 ] ) var1 -> X_low , ch ) ; 
} 
if ( ac -> oc [ number ] . m4ac . ps == number ) { 
if ( var1 -> ps . start ) { 
AAC_RENAME ( ff_ps_apply ) ( ac -> avctx , & var1 -> ps , var1 -> X [ number ] , var1 -> X [ number ] , var1 -> var10 [ number ] + var1 -> m [ number ] ) ; 
} else { 
memcpy ( var1 -> X [ number ] , var1 -> X [ number ] , sizeof ( var1 -> X [ number ] ) ) ; 
} 
nch = 2 ; 
} 
sbr_qmf_synthesis ( & var1 -> mdct , & var1 -> dsp , ac -> fdsp , 
L , var1 -> X [ number ] , var1 -> qmf_filter_scratch , 
var1 -> data [ number ] . synthesis_filterbank_samples , 
& var1 -> data [ number ] . synthesis_filterbank_samples_offset , 
downsampled ) ; 
if ( nch == 2 ) 
sbr_qmf_synthesis ( & var1 -> mdct , & var1 -> dsp , ac -> fdsp , 
R , var1 -> X [ number ] , var1 -> qmf_filter_scratch , 
var1 -> data [ number ] . synthesis_filterbank_samples , 
& var1 -> data [ number ] . synthesis_filterbank_samples_offset , 
downsampled ) ; 
} 
static void aacsbr_func_ptr_init ( AACSBRContext * c ) 
{ 
c -> sbr_lf_gen = sbr_lf_gen ; 
c -> sbr_hf_assemble = sbr_hf_assemble ; 
c -> sbr_x_gen = sbr_x_gen ; 
c -> sbr_hf_inverse_filter = sbr_hf_inverse_filter ; 
if ( ARCH_MIPS ) 
ff_aacsbr_func_ptr_init_mips ( c ) ; 
} 
