int func1 ( void * var1 , const AVOption * var2 ) 
{ 
int64_t var3 ; 
double var4 , var5 ; 
float var6 ; 
AVRational var7 ; 
int var8 , var9 , var10 ; 
char * var11 ; 
void * var12 ; 
if ( ! var2 || ! var1 ) 
return func2 ( var13 ) ; 
var12 = ( ( uint8_t * ) var1 ) + var2 -> var14 ; 
switch ( var2 -> var15 ) { 
case var16 : 
return number ; 
case var17 : 
case var18 : 
case var19 : 
case var20 : 
case var21 : 
case var22 : 
case var23 : 
func3 ( var2 , var12 , var24 , var24 , & var3 ) ; 
return var2 -> var25 . var3 == var3 ; 
case var26 : 
var11 = * ( char ** ) var12 ; 
if ( var11 == var2 -> var25 . var11 ) 
return number ; 
if ( ! var11 || ! var2 -> var25 . var11 ) 
return number ; 
return ! strcmp ( var11 , var2 -> var25 . var11 ) ; 
case var27 : 
func3 ( var2 , var12 , & var4 , var24 , var24 ) ; 
return var2 -> var25 . var28 == var4 ; 
case var29 : 
func3 ( var2 , var12 , & var4 , var24 , var24 ) ; 
var6 = var2 -> var25 . var28 ; 
var5 = var6 ; 
return var5 == var4 ; 
case var30 : 
var7 = func4 ( var2 -> var25 . var28 , var31 ) ; 
return ! func5 ( * ( AVRational * ) var12 , var7 ) ; 
case var32 : { 
struct { 
uint8_t * var33 ; 
int var34 ; 
} var35 = { number } ; 
int var36 = * ( int * ) ( ( void ** ) var12 + number ) ; 
void * var37 = * ( void ** ) var12 ; 
if ( ! var36 && ( ! var2 -> var25 . var11 || ! strlen ( var2 -> var25 . var11 ) ) ) 
return number ; 
if ( ! var36 || ! var2 -> var25 . var11 || ! strlen ( var2 -> var25 . var11 ) ) 
return number ; 
if ( var36 != strlen ( var2 -> var25 . var11 ) / number ) 
return number ; 
var8 = func6 ( var24 , var24 , var2 -> var25 . var11 , & var35 . var33 ) ; 
if ( ! var8 ) 
var8 = ! memcmp ( var37 , var35 . var33 , var35 . var34 ) ; 
func7 ( var35 . var33 ) ; 
return var8 ; 
} 
case var38 : 
return ! ! ( * ( void ** ) var12 ) ; 
case var39 : 
if ( ! var2 -> var25 . var11 || ! strcmp ( var2 -> var25 . var11 , var11 ) ) 
var9 = var10 = number ; 
else if ( ( var8 = func8 ( & var9 , & var10 , var2 -> var25 . var11 ) ) < number ) 
return var8 ; 
return ( var9 == * ( int * ) var12 ) && ( var10 == * ( ( int * ) var12 + number ) ) ; 
case var40 : 
var7 = ( AVRational ) { number , number } ; 
if ( var2 -> var25 . var11 ) { 
if ( ( var8 = func9 ( & var7 , var2 -> var25 . var11 ) ) < number ) 
return var8 ; 
} 
return ! func5 ( * ( AVRational * ) var12 , var7 ) ; 
case var41 : { 
uint8_t var42 [ number ] = { number , number , number , number } ; 
if ( var2 -> var25 . var11 ) { 
if ( ( var8 = func10 ( var42 , var2 -> var25 . var11 , - number , var24 ) ) < number ) 
return var8 ; 
} 
return ! memcmp ( var42 , var12 , sizeof ( var42 ) ) ; 
} 
var43 : 
func11 ( var1 , var44 , var11 , var2 -> var15 , var2 -> var45 ) ; 
break ; 
} 
return var46 ; 
} 
int av_opt_is_set_to_default_by_name ( void * var1 , const char * var45 , int search_flags ) 
{ 
const AVOption * var2 ; 
void * target ; 
if ( ! var1 ) 
return func2 ( var13 ) ; 
var2 = av_opt_find2 ( var1 , var45 , var24 , number , search_flags , & target ) ; 
if ( ! var2 ) 
return AVERROR_OPTION_NOT_FOUND ; 
return func1 ( target , var2 ) ; 
} 
int av_opt_serialize ( void * var1 , int opt_flags , int flags , char ** buffer , 
const char key_val_sep , const char pairs_sep ) 
{ 
const AVOption * var2 = var24 ; 
uint8_t * buf ; 
AVBPrint bprint ; 
int var8 , cnt = number ; 
const char special_chars [ ] = { pairs_sep , key_val_sep , str } ; 
if ( pairs_sep == str || key_val_sep == str || pairs_sep == key_val_sep || 
pairs_sep == str || key_val_sep == str ) { 
func11 ( var1 , AV_LOG_ERROR , str ) ; 
return func2 ( var13 ) ; 
} 
if ( ! var1 || ! buffer ) 
return func2 ( var13 ) ; 
* buffer = var24 ; 
av_bprint_init ( & bprint , 64 , AV_BPRINT_SIZE_UNLIMITED ) ; 
while ( var2 = av_opt_next ( var1 , var2 ) ) { 
if ( var2 -> var15 == var16 ) 
continue ; 
if ( ( flags & AV_OPT_SERIALIZE_OPT_FLAGS_EXACT ) && var2 -> flags != opt_flags ) 
continue ; 
else if ( ( ( var2 -> flags & opt_flags ) != opt_flags ) ) 
continue ; 
if ( flags & AV_OPT_SERIALIZE_SKIP_DEFAULTS && func1 ( var1 , var2 ) > number ) 
continue ; 
if ( ( var8 = av_opt_get ( var1 , var2 -> var45 , number , & buf ) ) < number ) { 
av_bprint_finalize ( & bprint , var24 ) ; 
return var8 ; 
} 
if ( buf ) { 
if ( cnt ++ ) 
av_bprint_append_data ( & bprint , & pairs_sep , number ) ; 
av_bprint_escape ( & bprint , var2 -> var45 , special_chars , AV_ESCAPE_MODE_BACKSLASH , number ) ; 
av_bprint_append_data ( & bprint , & key_val_sep , number ) ; 
av_bprint_escape ( & bprint , buf , special_chars , AV_ESCAPE_MODE_BACKSLASH , number ) ; 
av_freep ( & buf ) ; 
} 
} 
av_bprint_finalize ( & bprint , buffer ) ; 
return number ; 
} 
typedef struct TestContext 
{ 
const AVClass * class ; 
int num ; 
int toggle ; 
char * string ; 
int flags ; 
AVRational rational ; 
AVRational video_rate ; 
int var9 , var10 ; 
enum AVPixelFormat pix_fmt ; 
enum AVSampleFormat sample_fmt ; 
int64_t duration ; 
uint8_t var42 [ number ] ; 
int64_t channel_layout ; 
void * binary ; 
int binary_size ; 
void * binary1 ; 
int binary_size1 ; 
void * binary2 ; 
int binary_size2 ; 
int64_t num64 ; 
float flt ; 
double var28 ; 
char * escape ; 
} TestContext ; 
static const AVOption test_options [ ] = { 
{ str , str , OFFSET ( num ) , var20 , { . var3 = number } , number , 100 , number } , 
{ str , str , OFFSET ( toggle ) , var20 , { . var3 = number } , number , number , number } , 
{ str , str , OFFSET ( rational ) , var30 , { . var28 = number } , number , 10 , number } , 
{ str , str , OFFSET ( string ) , var26 , { . var11 = str } , CHAR_MIN , CHAR_MAX , number } , 
{ str , str , OFFSET ( escape ) , var26 , { . var11 = str } , CHAR_MIN , CHAR_MAX , number } , 
{ str , str , OFFSET ( flags ) , var17 , { . var3 = number } , number , var31 , number , str } , 
{ str , str , number , var16 , { . var3 = TEST_FLAG_COOL } , INT_MIN , var31 , number , str } , 
{ str , str , number , var16 , { . var3 = TEST_FLAG_LAME } , INT_MIN , var31 , number , str } , 
{ str , str , number , var16 , { . var3 = TEST_FLAG_MU } , INT_MIN , var31 , number , str } , 
{ str , str , OFFSET ( var9 ) , var39 , { . var11 = str } , number , number , number } , 
{ str , str , OFFSET ( pix_fmt ) , var18 , { . var3 = AV_PIX_FMT_0BGR } , - number , var31 , number } , 
{ str , str , OFFSET ( sample_fmt ) , var19 , { . var3 = AV_SAMPLE_FMT_S16 } , - number , var31 , number } , 
{ str , str , OFFSET ( video_rate ) , var40 , { . var11 = str } , number , number , number } , 
{ str , str , OFFSET ( duration ) , var22 , { . var3 = 1000 } , number , INT64_MAX , number } , 
{ str , str , OFFSET ( var42 ) , var41 , { . var11 = str } , number , number , number } , 
{ str , str , OFFSET ( channel_layout ) , var21 , { . var3 = AV_CH_LAYOUT_HEXAGONAL } , number , INT64_MAX , number } , 
{ str , str , OFFSET ( binary ) , var32 , { . var11 = str } , number , number , number } , 
{ str , str , OFFSET ( binary1 ) , var32 , { . var11 = var24 } , number , number , number } , 
{ str , str , OFFSET ( binary2 ) , var32 , { . var11 = str } , number , number , number } , 
{ str , str , OFFSET ( num64 ) , var23 , { . var3 = number } , number , 100 , number } , 
{ str , str , OFFSET ( flt ) , var29 , { . var28 = number . number / 3 } , number , 100 , number } , 
{ str , str , OFFSET ( var28 ) , var27 , { . var28 = number . number / 3 } , number , 100 , number } , 
{ var24 } , 
} ; 
static const char * test_get_name ( void * ctx ) 
{ 
return str ; 
} 
static const AVClass test_class = { 
str , 
test_get_name , 
test_options 
} ; 
static void log_callback_help ( void * ptr , int level , const char * fmt , va_list vl ) 
{ 
vfprintf ( stdout , fmt , vl ) ; 
} 
int main ( void ) 
{ 
int i ; 
av_log_set_level ( AV_LOG_DEBUG ) ; 
av_log_set_callback ( log_callback_help ) ; 
printf ( str ) ; 
{ 
TestContext test_ctx = { number } ; 
test_ctx . class = & test_class ; 
av_opt_set_defaults ( & test_ctx ) ; 
printf ( str , test_ctx . num ) ; 
printf ( str , test_ctx . toggle ) ; 
printf ( str , test_ctx . string ) ; 
printf ( str , test_ctx . escape ) ; 
printf ( str , test_ctx . flags ) ; 
printf ( str , test_ctx . rational . num , test_ctx . rational . den ) ; 
printf ( str , test_ctx . video_rate . num , test_ctx . video_rate . den ) ; 
printf ( str , test_ctx . var9 , test_ctx . var10 ) ; 
printf ( str , av_get_pix_fmt_name ( test_ctx . pix_fmt ) ) ; 
printf ( str , av_get_sample_fmt_name ( test_ctx . sample_fmt ) ) ; 
printf ( str PRId64 str , test_ctx . duration ) ; 
printf ( str , test_ctx . var42 [ number ] , test_ctx . var42 [ number ] , test_ctx . var42 [ number ] , test_ctx . var42 [ 3 ] ) ; 
printf ( str PRId64 str PRId64 str , test_ctx . channel_layout , ( int64_t ) AV_CH_LAYOUT_HEXAGONAL ) ; 
if ( test_ctx . binary ) 
printf ( str , ( ( uint8_t * ) test_ctx . binary ) [ number ] , ( ( uint8_t * ) test_ctx . binary ) [ number ] , ( ( uint8_t * ) test_ctx . binary ) [ number ] , ( ( uint8_t * ) test_ctx . binary ) [ 3 ] ) ; 
printf ( str , test_ctx . binary_size ) ; 
printf ( str PRId64 str , test_ctx . num64 ) ; 
printf ( str , test_ctx . flt ) ; 
printf ( str , test_ctx . var28 ) ; 
av_opt_show2 ( & test_ctx , var24 , - number , number ) ; 
av_opt_free ( & test_ctx ) ; 
} 
printf ( str ) ; 
{ 
int var8 ; 
TestContext test_ctx = { number } ; 
const AVOption * var2 = var24 ; 
test_ctx . class = & test_class ; 
av_log_set_level ( AV_LOG_QUIET ) ; 
while ( var2 = av_opt_next ( & test_ctx , var2 ) ) { 
var8 = av_opt_is_set_to_default_by_name ( & test_ctx , var2 -> var45 , number ) ; 
printf ( str , var2 -> var45 , ! ! var8 , var8 < number ? av_err2str ( var8 ) : str ) ; 
} 
av_opt_set_defaults ( & test_ctx ) ; 
while ( var2 = av_opt_next ( & test_ctx , var2 ) ) { 
var8 = av_opt_is_set_to_default_by_name ( & test_ctx , var2 -> var45 , number ) ; 
printf ( str , var2 -> var45 , ! ! var8 , var8 < number ? av_err2str ( var8 ) : str ) ; 
} 
av_opt_free ( & test_ctx ) ; 
} 
printf ( str ) ; 
{ 
TestContext test_ctx = { number } ; 
char * buf ; 
test_ctx . class = & test_class ; 
av_log_set_level ( AV_LOG_QUIET ) ; 
av_opt_set_defaults ( & test_ctx ) ; 
if ( av_opt_serialize ( & test_ctx , number , number , & buf , str , str ) >= number ) { 
printf ( str , buf ) ; 
av_opt_free ( & test_ctx ) ; 
memset ( & test_ctx , number , sizeof ( test_ctx ) ) ; 
test_ctx . class = & test_class ; 
av_set_options_string ( & test_ctx , buf , str , str ) ; 
func7 ( buf ) ; 
if ( av_opt_serialize ( & test_ctx , number , number , & buf , str , str ) >= number ) { 
printf ( str , buf ) ; 
func7 ( buf ) ; 
} 
} 
av_opt_free ( & test_ctx ) ; 
} 
printf ( str ) ; 
{ 
TestContext test_ctx = { number } ; 
static const char * const options [ ] = { 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
} ; 
test_ctx . class = & test_class ; 
av_opt_set_defaults ( & test_ctx ) ; 
av_log_set_level ( AV_LOG_QUIET ) ; 
for ( i = number ; i < FF_ARRAY_ELEMS ( options ) ; i ++ ) { 
int silence_log = ! strcmp ( options [ i ] , str ) ; 
func11 ( & test_ctx , AV_LOG_DEBUG , str , options [ i ] ) ; 
if ( silence_log ) 
av_log_set_callback ( var24 ) ; 
if ( av_set_options_string ( & test_ctx , options [ i ] , str , str ) < number ) 
printf ( str , options [ i ] ) ; 
else 
printf ( str , options [ i ] ) ; 
av_log_set_callback ( log_callback_help ) ; 
} 
av_opt_free ( & test_ctx ) ; 
} 
printf ( str ) ; 
{ 
TestContext test_ctx = { number } ; 
static const char * const options [ ] = { 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str , 
str 
} ; 
static const char * const shorthand [ ] = { str , str , var24 } ; 
test_ctx . class = & test_class ; 
av_opt_set_defaults ( & test_ctx ) ; 
av_log_set_level ( AV_LOG_QUIET ) ; 
for ( i = number ; i < FF_ARRAY_ELEMS ( options ) ; i ++ ) { 
func11 ( & test_ctx , AV_LOG_DEBUG , str , options [ i ] ) ; 
if ( av_opt_set_from_string ( & test_ctx , options [ i ] , shorthand , str , str ) < number ) 
printf ( str , options [ i ] ) ; 
else 
printf ( str , options [ i ] ) ; 
} 
av_opt_free ( & test_ctx ) ; 
} 
return number ; 
} 
